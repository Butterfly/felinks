#!/usr/bin/perl -w
use strict;
use warnings;
use diagnostics;
use Getopt::Std;

my $HELP = "Usage: $0 [FILE]
	Parses [FILE], outputing the result to stdout.";

sub usage {
	print "@_\n";
	exit;
}

our($opt_h, $opt_v);
getopts("hv") or usage($HELP);
$opt_v and usage("Copyleft (c) 2006, Russ Rowan (See `COPYING')");
usage($HELP) if $opt_h or @ARGV < 1;

my ($found, $start, $first, $gotone, $idpath);
$idpath = '';
while (<>)
{
	# Match:
	#	IDENT,         /*:: ... */
	#	IDENT = value, /*:: ... */
	#	type ident;    /*:: ... */
	if ($_ =~ /^(\s|[^\s=]+)*[\s*]([A-Za-z0-9_]+)(\s+=\s+[^,;]+)?[,;]\s*\/\*::\s*(.*)\s+\*\/$/)
	{
		print "\nid:[$idpath$2]::\n\t$4\n";
		next;
	}

	if ($found)
	{
		if ($_ =~ /^\s+\*\s$/) { next if $first; $_ =~ s/\s\*// if not $first; }
		if ($_ =~ /^\s\*+\/$/ or $_ !~ /^\s/) { $found = undef; next; }
		$_ =~ s/^(\s*)\s\*\s/$1/;
		$found = 'sorta' if $_ =~ s/\s*\*\/$/\n/; $first = undef;
	}
	elsif ($_ =~ /^\s*\/\*\*\s(.*)/)
	{
		$_ = $1; $first = 1;
		print STDOUT "\n\n" if $start;
		if ($_ =~ s/\s*\*\/$//) { $found = 'sorta'; } else { $found = $.; }
		if ($_ =~ /struct:[[]([^\]]+)[\]]/) { $idpath = "$1."; } else { $idpath = ''; }
		if ($_ =~ /::/) { $_ = "$_\n\n"; }
		else
		{
			my $dash; for (my $x = 0; $x < length($_); $x++) { $dash .= '-'; }
			$_ = "$_\n$dash\n\n";
		}
	}
	print STDOUT "\n" and $gotone = undef if $gotone and $gotone < $.;
	next if not $found;  $found = undef if $found eq 'sorta';
	print STDOUT $_ and $start = 1;
}
